%% @doc Benchmark JSON decoding. Probably not the best suite, since
%% decoding is done in the basho_bench VM, but it gives an idea.
%%
%% Set `json_decoder' in the config file to the name of the module
%% exporting the `decode/1' function for your decoder
%% (e.g. `mochijson2', `fj').
%%
%% Available operations are:
%% <ul>
%% <li>`{decode, int}' - decode an integer generated by
%%     `value_generator'</li>
%% <li>`{decode, float}' - decode a float generated by appending two
%%     calls to the `value_generator' with a dot</li>
%% <li>`{decode, {string, unicode}}' - decode a `\uXXXX' unicode
%%     character</li>
%% <li>`{decode, {string, Length::integer()}}' - decode a plain string
%%     of digits, length very rougly determined by Length</li>
%% <li>`{decode, boolean}' - decode a boolean</li>
%% <li>`{decode, {array, Length::integer()}}' - decode an array of
%%     `Length' integers (each generated by `value_generator'</li>
%% <li>`{decode, {object, Length::integer()}}' - decode an object with
%%     `Length' fields (keys generated by `key_generator', values
%%     generated by `value_generator'</li>
%% </ul>
%%
%% The `decode' prefix in the above operations is intended to allow
%% room for an `encode' prefix later.
%%
%% See the accompanying `json.config` file for an example.
-module(basho_bench_driver_json).

-export([new/1,
         run/4]).

-include("basho_bench.hrl").

-record(state, {decoder}).        % Params to append on the path


%% ====================================================================
%% API
%% ====================================================================

new(Id) ->

    ?DEBUG("ID: ~p\n", [Id]),

    Decoder = basho_bench_config:get(json_decoder),
    
    {ok, #state{decoder=Decoder}}.

run({decode, int}, _KeyGen, ValueGen, State) ->
    JSON = integer_to_list(ValueGen()),
    decode(JSON, State);
run({decode, float}, _KeyGen, ValueGen, State) ->
    JSON = [integer_to_list(ValueGen()),".",integer_to_list(ValueGen())],
    decode(JSON, State);
run({decode, {string, unicode}}, _KeyGen, ValueGen, State) ->
    JSON = io_lib:format("\"\\u~4..0b\"", [ValueGen()]),
    decode(JSON, State);
run({decode, {string, Length}}, _KeyGen, ValueGen, State) ->
    JSON = ["\"",
            [integer_to_list(ValueGen()) || _ <- lists:seq(1, Length)],
            "\""],
    decode(JSON, State);
run({decode, boolean}, _KeyGen, ValueGen, State) ->
    JSON = case ValueGen() rem 2 of
               0 -> "true";
               1 -> "false"
           end,
    decode(JSON, State);
run({decode, {array, Length}}, _KeyGen, ValueGen, State) ->
    JSON = ["[",
            string:join([ integer_to_list(ValueGen())
                          || _ <- lists:seq(1, Length) ],
                        ","),
            "]"],
    decode(JSON, State);
run({decode, {object, Length}}, KeyGen, ValueGen, State) ->
    JSON = ["{",
            string:join([ ["\"",
                           integer_to_list(KeyGen()),
                           "\":",
                           integer_to_list(ValueGen())]
                          || _ <- lists:seq(1, Length) ],
                        ","),
            "}"],
    decode(JSON, State).

%% ====================================================================
%% Internal functions
%% ====================================================================

decode(JSON, #state{decoder=Decoder}=State) ->
    %%TODO: rpc?
    Decoder:decode(list_to_binary(JSON)),
    {ok, State}.
